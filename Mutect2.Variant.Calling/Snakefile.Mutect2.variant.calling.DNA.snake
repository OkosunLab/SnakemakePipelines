##########################################################
##
## Snakefile for the processing of UMI based DNA seq
##
## Written by: Findlay Bewicke-Copley
## Date: 13-05-2024
##########################################################

import glob

## Load config file
configfile: "Mutect2.Variant.Calling.yaml"
## Used for FASTQC
READS=["R1", "R2"]
READS2=["1", "2"]
## Dynamically file all the sample IDs
## First build the search string
search="%s/{sample}_S{number}_{lane}_R1_001.fastq.gz" % config["AlignedFiles"]
## Then find all the samples
SAMPLES = set(glob_wildcards(search).sample)

##########################################################
## Functions
##########################################################

## Find all FASTQ files of a specific read given the sample ID

def get_R1(wildcards):
	files = glob.glob('{}/{}*R1*.fastq.gz'.format(config["rawFolder"], wildcards.sample))
	files.sort()
	return files

def get_R2(wildcards):
	files = glob.glob('{}/{}*R3*.fastq.gz'.format(config["rawFolder"], wildcards.sample))
	files.sort()
	return files

def get_UMI(wildcards):
	files = glob.glob('{}/{}*R2*.fastq.gz'.format(config["rawFolder"], wildcards.sample))
	files.sort()
	return files

 
## Find all FASTQ files given the sample ID and read ID

def get_fastq_from_sample_read(wildcards):
	files = glob.glob('FASTQ_Raw/Combined/{}*{}*.fastq.gz'.format(wildcards.sample, wildcards.read))
	return files


##########################################################
## RULES
##########################################################

## One rule to run them all

rule all:
	input:
		expand("Alignment/{sample}.con.recalib.bam", sample = SAMPLES),
		"QC/MultiQC/multiqc_report.html"

##########################################################
## QC and file manuipulation
##########################################################

rule mutect2:
	input:
		map="Alignment/{sample}.con.recalib.bam",
		fasta=config["reference"],
		pon=config["pon"]
	output:
		vcf="VCF/{sample}.vcf",
		f1r2="Counts/{sample}.f1r2.tar.gz"
	threads: 
		config["mutect2Threads"]
	params:
		mem=config["gatkMem"]
	resources:
		mem_mb=config["gatkRunMem"]
	log:
		"logs/mutect2/{sample}.log"
	wrapper:
		"v3.10.2/bio/gatk/mutect"

rule gatk_get_pileup_summaries:
	input:
		bam="Alignment/{sample}.con.recalib.bam",
		variants=config["gnomad"],
		intervals=config["intervals"]
	output:
		"Counts/{sample}.summaries.table",
	threads: 
		config["mutect2Threads"]
	params:
		mem=config["gatkMem"]
	resources:
		mem_mb=config["gatkRunMem"]
	log:
		"logs/gatk_pileup/{sample}.summary.log",
	wrapper:
		"v3.10.2/bio/gatk/getpileupsummaries"

rule gatk_calculate_contamination:
	input:
		tumor="Counts/{sample}.summaries.table",
	output:
		"Counts/{sample}.contamination.table",
	threads: 
		config["mutect2Threads"]
	params:
		mem=config["gatkMem"],
		extra="-tumor-segmentation Counts/{sample}segmentation.tsv"
	resources:
		mem_mb=config["gatkRunMem"]
	log:
		"logs/gatk_contam/{sample}.contamination.log",
	wrapper:
		"v3.10.2/bio/gatk/calculatecontamination"

rule gatk_learnreadorientationmodel:
	input:
		f1r2="Counts/{sample}.f1r2.tar.gz",
	output:
		"Counts/{sample}.artifacts_prior.tar.gz",
	threads: 
		config["mutect2Threads"]
	params:
		mem=config["gatkMem"]
	resources:
		mem_mb=config["gatkRunMem"]
	log:
		"logs/gatk_oreintation/{sample}.learnreadorientationbias.log",
	wrapper:
		"v3.10.2/bio/gatk/learnreadorientationmodel"

rule gatk_filtermutectcalls_complete:
	input:
		vcf="VCF/{sample}.vcf",
		ref=config["reference"],
		bam="Alignment/{sample}.con.recalib.bam",
		contamination="Counts/{sample}.contamination.table",
		segmentation="Counts/{sample}segmentation.tsv", 
		f1r2="Counts/{sample}.f1r2.tar.gz"
	output:
		vcf="VCF/{sample}.snvs.mutect.filtered.vcf",
	log:
		"logs/gatk_filter/{sample}.filter.snvs.log",
	params:
		mem=config["gatkMem"]
		extra="--max-alt-allele-count 3",
		java_opts="",
	resources:
		mem_mb=config["gatkRunMem"]
	wrapper:
		"v3.10.2/bio/gatk/filtermutectcalls"
